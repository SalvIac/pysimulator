# -*- coding: utf-8 -*-
# pysimulator
# Copyright (C) 2021-2022 Salvatore Iacoletti
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
"""

from functools import lru_cache

import numpy as np
from numpy.testing import assert_equal
import pandas as pd
from scipy import interpolate, stats




# sampling functions
class Sampler(object):
    def __init__(self, distname, seed=None):
        self.distname = distname
        self.seed = seed
        if seed is not None:
            np.random.seed(seed=self.seed)

    def get_loss_ratios(self, _means, _covs):
        # vals = df['val'].to_numpy()
        # if not self.rng or not covs:  # fast lane
        #     losses = vals * df['mean'].to_numpy()
        # else:  # slow lane
        losses = getattr(self, 'sample' + self.distname)(_means, _covs)
        return losses

    def sampleLN(self, _means, _covs):
        # from MultiEventRNG
        eps = stats.norm.rvs(size=_means.shape[0])
        sigma = np.sqrt(np.log(1 + _covs ** 2))
        div = np.sqrt(1 + _covs ** 2)
        return _means * np.exp(eps * sigma) / div

    def sampleBT(self, _mean, _covs):
        raise Exception("not done yet!")




class VulnerabilityFunction(object):
    seed = None  # to be overridden

    def __init__(self, vf_id, imt, imls, mean_loss_ratios, covs=None,
                 distribution="LN", vtype="Undamaged"):
        """
        :param str vf_id: Vulnerability Function ID
        :param str imt: Intensity Measure Type as a string
        :param list imls: Intensity Measure Levels for the
            vulnerability function. All values must be >= 0.0, values
            must be arranged in ascending order with no duplicates
        :param list mean_loss_ratios: Mean Loss ratio values, equal in
        length to imls, where value >= 0.
        :param list covs: Coefficients of Variation. Equal in length
        to mean loss ratios. All values must be >= 0.0.
        :param str distribution_name: The probabilistic distribution
            related to this function.
        """
        self.id = vf_id
        self.imt = imt
        self._check_vulnerability_data(
            imls, mean_loss_ratios, covs, distribution)
        self.imls = np.array(imls)
        self.mean_loss_ratios = np.array(mean_loss_ratios)

        if covs is not None:
            self.covs = np.array(covs)
        else:
            self.covs = np.zeros(self.imls.shape)

        for lr, cov in zip(self.mean_loss_ratios, self.covs):
            if lr == 0 and cov > 0:
                msg = ("It is not valid to define a mean loss ratio = 0 "
                       "with a corresponding coefficient of variation > 0")
                raise ValueError(msg)
            if cov < 0:
                raise ValueError(
                    'Found a negative coefficient of variation in %s' %
                    self.covs)
            if distribution == 'BT':
                if lr == 0:  # possible with cov == 0
                    pass
                elif lr > 1:
                    raise ValueError(
                        'The meanLRs must be below 1, got %s' % lr)
                elif cov ** 2 > 1 / lr - 1:
                    # see https://github.com/gem/oq-engine/issues/4841
                    raise ValueError(
                        'The coefficient of variation %s > %s does not '
                        'satisfy the requirement 0 < sig < sqrt[mu × (1 - mu)]'
                        ' in %s' % (cov, np.sqrt(1 / lr - 1), self))

        self.distribution_name = distribution
        self.vulnerability_type = vtype # "Undamaged" "ds1" "ds2" and so on
        self.init()


    def init(self):
        # called by CompositeRiskModel and by __setstate__
        self.covs = np.float64(self.covs)
        self.mean_loss_ratios = np.float64(self.mean_loss_ratios)
        self._stddevs = self.covs * self.mean_loss_ratios
        self._mlr_i1d = interpolate.interp1d(self.imls, self.mean_loss_ratios)
        self._covs_i1d = interpolate.interp1d(self.imls, self.covs)


    def interpolate(self, gmvs):
        """
        interpolated loss ratios and covs
        """
        # gmvs are clipped to max(iml)
        gmvs_curve = np.piecewise(
            gmvs, [gmvs > self.imls[-1]], [self.imls[-1], lambda x: x])
        ok = gmvs_curve >= self.imls[0]  # indices over the minimum #TODO
        curve_ok = gmvs_curve[ok]
        _means = np.zeros(gmvs_curve.shape[0])
        _covs = np.zeros(gmvs_curve.shape[0])
        _means[ok] = self._mlr_i1d(curve_ok)
        _covs[ok] = self._cov_for(curve_ok)
        return _means, _covs


    def __call__(self, gmfv, minloss=0):
        """
        :param gmfv: a numpy array of GMFs
        :returns: loss_ratios and variances
        """
        _means, _covs = self.interpolate(gmfv)  # really fast
        sampler = Sampler(self.distribution_name)
        loss_ratios = sampler.get_loss_ratios(_means, _covs)
        loss_ratios[loss_ratios < minloss] = 0.
        variances = (loss_ratios * _covs)**2
        return loss_ratios, variances

    def strictly_increasing(self):
        """
        :returns:
          a new vulnerability function that is strictly increasing.
          It is built by removing piece of the function where the mean
          loss ratio is constant.
        """
        imls, mlrs, covs = [], [], []

        previous_mlr = None
        for i, mlr in enumerate(self.mean_loss_ratios):
            if previous_mlr == mlr:
                continue
            else:
                mlrs.append(mlr)
                imls.append(self.imls[i])
                covs.append(self.covs[i])
                previous_mlr = mlr

        return self.__class__(
            self.id, self.imt, imls, mlrs, covs, self.distribution_name)


    def _cov_for(self, imls):
        """
        Clip `imls` to the range associated with the support of the
        vulnerability function and returns the corresponding
        covariance values by linear interpolation. For instance
        if the range is [0.005, 0.0269] and the imls are
        [0.0049, 0.006, 0.027], the clipped imls are
        [0.005,  0.006, 0.0269].
        """
        return self._covs_i1d(
            np.piecewise(
                imls,
                [imls > self.imls[-1], imls < self.imls[0]],
                [self.imls[-1], self.imls[0], lambda x: x]))

    
    # otherwise it doesn't pickle https://stackoverflow.com/questions/40768675/use-pickle-to-load-a-state-for-class
    # def __getstate__(self):
    #     return (self.id, self.imt, self.imls, self.mean_loss_ratios,
    #             self.covs, self.distribution_name, self.vulnerability_type)


    def _check_vulnerability_data(self, imls, loss_ratios, covs, distribution):
        assert_equal(imls, sorted(set(imls)))
        assert all(x >= 0.0 for x in imls)
        assert covs is None or len(covs) == len(imls)
        assert len(loss_ratios) == len(imls)
        assert all(x >= 0.0 for x in loss_ratios)
        assert covs is None or all(x >= 0.0 for x in covs)
        assert distribution in ["LN", "BT"]

    def __repr__(self):
        return '<{}({}, {}, {})>'.format(
            self.__class__.__name__, self.id, self.imt, self.vulnerability_type)
            







class VulnerabilityDamDepFunction(object):
    seed = None  # to be overridden

    def __init__(self, vf_id, imt, imls, mean_loss_ratios, covs=None,
                 distribution="LN", vtype="Undamaged"):
        """
        It's basically a collection of VulnerabilityFunction and Fragility
        """
        self.id = vf_id
        self.imt = imt
        self.vulnerability_type = vtype


    def __call__(self, gmfv, minloss=0):
        """
        :param gmfv: a numpy array of GMFs
        :returns: loss_ratios and variances
        """
        _means, _covs = self.interpolate(gmfv)  # really fast
        sampler = Sampler(self.distribution_name)
        loss_ratios = sampler.get_loss_ratios(_means, _covs)
        loss_ratios[loss_ratios < minloss] = 0.
        variances = (loss_ratios * _covs)**2
        return loss_ratios, variances


    def __repr__(self):
        return '<{}({}, {}, {})>'.format(
            self.__class__.__name__, self.id, self.imt, self.vulnerability_type)

    
    @classmethod
    def get_ds_combinations(cls, damage_states):
        '''
        list of damage_states in order. e.g. ["Undamaged", "DS1", "DS2", "DS3"]
        '''
        combo = dict()
        for i in range(0, len(damage_states)-1): # existing (previous) state
            combo[damage_states[i]] = list()
            for j in range(i+1, len(damage_states)): # following state
                combo[damage_states[i]].append( damage_states[j] )
        return combo






class VulnerabilitySurface(object):
    seed = None  # to be overridden

    def __init__(self, vf_id, imt, imls1, imls2, mean_loss_ratios, covs=None,
                 distribution="LN"):
        """
        :param str vf_id: Vulnerability Function ID
        :param str imt: Intensity Measure Type as a string
        :param list imls: Intensity Measure Levels for the
            vulnerability function. All values must be >= 0.0, values
            must be arranged in ascending order with no duplicates
        :param list mean_loss_ratios: Mean Loss ratio values, equal in
        length to imls, where value >= 0.
        :param list covs: Coefficients of Variation. Equal in length
        to mean loss ratios. All values must be >= 0.0.
        :param str distribution_name: The probabilistic distribution
            related to this function.
        """
        self.id = vf_id
        self.imt = imt
        self._check_vulnerability_data(
            imls1, imls2, mean_loss_ratios, covs, distribution)
        self.imls1 = np.array(imls1)
        self.imls2 = np.array(imls2)
        self.mean_loss_ratios = np.array(mean_loss_ratios)

        if covs is not None:
            self.covs = np.array(covs)
        else:
            self.covs = np.zeros(self.mean_loss_ratios.shape)

        for lr, cov in zip(self.mean_loss_ratios.flatten(), self.covs.flatten()):
            if lr == 0 and cov > 0:
                msg = ("It is not valid to define a mean loss ratio = 0 "
                       "with a corresponding coefficient of variation > 0")
                raise ValueError(msg)
            if cov < 0:
                raise ValueError(
                    'Found a negative coefficient of variation in %s' %
                    self.covs)
            if distribution == 'BT':
                if lr == 0:  # possible with cov == 0
                    pass
                elif lr > 1:
                    raise ValueError(
                        'The meanLRs must be below 1, got %s' % lr)
                elif cov ** 2 > 1 / lr - 1:
                    # see https://github.com/gem/oq-engine/issues/4841
                    raise ValueError(
                        'The coefficient of variation %s > %s does not '
                        'satisfy the requirement 0 < sig < sqrt[mu × (1 - mu)]'
                        ' in %s' % (cov, np.sqrt(1 / lr - 1), self))

        self.distribution_name = distribution
        self.init()


    def init(self):
        # called by CompositeRiskModel and by __setstate__
        self.covs = np.float64(self.covs)
        self.mean_loss_ratios = np.float64(self.mean_loss_ratios)
        self._stddevs = np.multiply(self.covs, self.mean_loss_ratios)
        self._mlr_i2d = interpolate.RectBivariateSpline(self.imls1, self.imls2,
                                                        self.mean_loss_ratios)
        self._covs_i2d = interpolate.RectBivariateSpline(self.imls1, self.imls2,
                                                         self.covs)
        # slower
        # self._mlr_i2d = interpolate.interp2d(self.imls1, self.imls2,
        #                                       self.mean_loss_ratios.T, kind="linear")
        # self._covs_i2d = interpolate.interp2d(self.imls1, self.imls2,
        #                                       self.covs.T, kind="linear")
        # np.array([self._mlr_i2d(xx, yy) for xx, yy in zip(x,y)])
          

    def interpolate(self, gmvs1, gmvs2):
        """
        interpolated loss ratios and covs
        """
        # gmvs are clipped to max(iml)
        gmvs_curve1 = np.piecewise(
            gmvs1, [gmvs1 > self.imls1[-1]], [self.imls1[-1], lambda x: x])
        gmvs_curve2 = np.piecewise(
            gmvs2, [gmvs2 > self.imls2[-1]], [self.imls2[-1], lambda x: x])

        # ok1 = gmvs_curve1 >= vuln.imls1[0]  # indices over the minimum
        # ok2 = gmvs_curve2 >= vuln.imls2[0]  # indices over the minimum
        # _means = np.zeros(gmvs_curve1.shape[0])
        # _covs = np.zeros(gmvs_curve1.shape[0])
        _means = self._mlr_i2d.ev(gmvs_curve1, gmvs_curve2)
        _covs = self._cov_for(gmvs_curve1, gmvs_curve2)
        return _means, _covs


    def __call__(self, gmfv1, gmfv2, minloss=0):
        """
        :param gmfv: a numpy array of GMFs
        :returns: loss_ratios and variances
        """
        _means, _covs = self.interpolate(gmfv1, gmfv2)  # really fast
        sampler = Sampler(self.distribution_name)
        loss_ratios = sampler.get_loss_ratios(_means, _covs)
        loss_ratios[loss_ratios < minloss] = 0.
        variances = (loss_ratios * _covs)**2
        return loss_ratios, variances



    def _cov_for(self, imls1, imls2):
        """
        Clip `imls` to the range associated with the support of the
        vulnerability function and returns the corresponding
        covariance values by linear interpolation. For instance
        if the range is [0.005, 0.0269] and the imls are
        [0.0049, 0.006, 0.027], the clipped imls are
        [0.005,  0.006, 0.0269].
        """
        return self._covs_i2d.ev(
            np.piecewise(
                imls1,
                [imls1 > self.imls1[-1], imls1 < self.imls1[0]],
                [self.imls1[-1], self.imls1[0], lambda x: x]), 
            np.piecewise(
                imls2,
                [imls2 > self.imls2[-1], imls2 < self.imls2[0]],
                [self.imls2[-1], self.imls2[0], lambda x: x]), )


    # otherwise it doesn't pickle https://stackoverflow.com/questions/40768675/use-pickle-to-load-a-state-for-class
    # def __getstate__(self):
    #     return (self.id, self.imt, self.imls1, self.imls2, self.mean_loss_ratios,
    #             self.covs, self.distribution_name)


    def _check_vulnerability_data(self, imls1, imls2, loss_ratios, covs,
                                  distribution):
        assert_equal(imls1, sorted(set(imls1)))
        assert all(x >= 0.0 for x in imls1)
        assert_equal(imls2, sorted(set(imls2)))
        assert all(x >= 0.0 for x in imls2)
        assert covs is None or covs.shape[0] == len(imls1)
        assert covs is None or covs.shape[1] == len(imls2)
        assert loss_ratios.shape[0] == len(imls1)
        assert loss_ratios.shape[1] == len(imls2)
        assert all(x >= 0.0 for x in loss_ratios.flatten())
        assert covs is None or all(x >= 0.0 for x in covs.flatten())
        assert distribution in ["LN", "BT"]

    def __repr__(self):
        return '<{}({}, {})>'.format(
            self.__class__.__name__, self.id, self.imt)












#%%



if __name__ == "__main__":
    
    vf_id = "RC"
    imt = ("avgSa", 0.3) # "PGA"
    gmfv = np.array([0.12, 1.54, 2.5, 3.5])
    distribution = "LN"

    df = pd.read_csv("data/vulnerability_curves.csv")
    imls = df.iloc[:,0].to_numpy()
    mean_loss_ratios = df.iloc[:,1].to_numpy()
    covs = df.iloc[:,2].to_numpy()
    vtype = "Undamaged"
    vuln = VulnerabilityFunction(vf_id, imt, imls, mean_loss_ratios, covs,
                                 distribution, vtype)
    print(vuln(gmfv))


    import matplotlib.pyplot as plt
    
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.plot(vuln.imls, vuln.mean_loss_ratios)
    ax.set_xlabel(r'$IM\ (g)$')
    ax.set_ylabel(r'$LR$')
    plt.show()
    



    df = pd.read_csv("data/vulnerability_surface.csv")
    # df = df.iloc[:,:301]
    imls1 = df.iloc[:,0].to_numpy()
    imls2 = df.columns[1:].to_numpy().astype(float)
    mean_loss_ratios = df.iloc[:,1:].to_numpy()
    covs = None # df.iloc[:,2].to_numpy()
    vuln = VulnerabilitySurface(vf_id, imt, imls1, imls2, mean_loss_ratios,
                                covs, distribution)
        
    # x, y = np.random.rand(10000)*3, np.random.rand(10000)*1.495    
    gmvs1 = np.array([0.12, 1.54, 3.5, 2.5]) # this is the previous event gm
    gmvs2 = np.array([1.54,  3.5, 2.5, 0.12]) # this is the current event gm
    z = vuln(gmvs1, gmvs2)
    
    X = imls1
    Y = imls2
    Z = mean_loss_ratios
    
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.ticklabel_format(useOffset=False)
    plt.rcParams['image.cmap'] = 'coolwarm'
    xx, yy = np.meshgrid(X, Y)
    ax.contourf(xx.T, yy.T, Z, 20, cmap=plt.cm.coolwarm)
    pcm=ax.get_children()[2] #get the mappable, the 1st and the 2nd are the x and y axes
    plt.colorbar(pcm, ax=ax, cmap=plt.cm.coolwarm) 
    c = ax.contour(xx.T, yy.T, Z, 10, colors='black')
    plt.clabel(c, inline=True, fontsize=8, fmt='%1.1f')
    ax.set_xlabel(r'$IM_1\ (g)$')
    ax.set_ylabel(r'$IM_2\ (g)$')
    plt.show()
    # print(vuln(gmfv))



    from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.ticklabel_format(useOffset=False)
    xx, yy = np.meshgrid(X, Y)
    ax.plot_surface(xx.T, yy.T, Z, alpha=0.7, cmap=plt.cm.coolwarm)
    ax.contourf(xx.T, yy.T, Z, zdir='z', offset=-0, cmap=plt.cm.coolwarm)
    ax.scatter(gmvs1, gmvs2, z[0])
        
    #give the labels to each point
    for x_label, y_label, z_label, label in zip(gmvs1, gmvs2, z[0], [1,2,3,4]):
        ax.text(x_label, y_label, z_label, label)
        
    ax.set_xlabel(r'$IM_1\ (g)$')
    ax.set_ylabel(r'$IM_2\ (g)$')
    ax.set_zlabel('Loss ratio')
    plt.show()




